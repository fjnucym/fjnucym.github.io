<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Qt中将二进制数据转换为Base64编码格式</title>
      <link href="/2021/07/20/qt-zhong-jiang-er-jin-zhi-shu-ju-zhuan-huan-wei-base64-bian-ma-ge-shi/"/>
      <url>/2021/07/20/qt-zhong-jiang-er-jin-zhi-shu-ju-zhuan-huan-wei-base64-bian-ma-ge-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>QJson格式是只支持字符传输的，不支持二进制文件（例如图片）。我们可以将二进制文件转换为base64字符串达到转换二进制图片文件为字符串的形式存入QJson</p><p><strong>base64是什么？</strong></p><blockquote><p>Base64是网络上最常见的用于传输字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范。</p><p>Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。</p></blockquote><h2 id="QByteArray-binary-gt-QByteArray-base64"><a href="#QByteArray-binary-gt-QByteArray-base64" class="headerlink" title="QByteArray(binary) -&gt; QByteArray(base64)"></a>QByteArray(binary) -&gt; QByteArray(base64)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="function">QByteArray <span class="title">openBinaryFileAndGetBase64</span><span class="params">(QString fileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ---------------打开文件，加载二进制文件----------------</span></span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;image/picture.jpg&quot;</span>)</span></span>;<span class="comment">// 当然，你可以使用变量fileName</span></span><br><span class="line">    <span class="comment">// [重要] QIODevice使用前必须显示使用open</span></span><br><span class="line">    <span class="keyword">if</span>(!file.<span class="built_in">open</span>(QIODevice::ReadOnly))&#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;open file error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QByteArray byteArray = file.<span class="built_in">readAll</span>();</span><br><span class="line">    <span class="comment">// ----------------二进制字符数组转base64字符---------</span></span><br><span class="line">    byteArray = byteArray.<span class="built_in">toBase64</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> byteArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，但是很遗憾，虽然QByteArray本身使用字符类型数组作为底层数据结构，QJson却不支持直接使用QByteArray传图片（QJson没有这个基本类型啊！！！）。所以我们需要将QByteArray（base64）-&gt; QString 才能存QJson里边（QJson的基本类型有QString）。</p><h2 id="QByteArray（base64）-gt-QString-base64"><a href="#QByteArray（base64）-gt-QString-base64" class="headerlink" title="QByteArray（base64） -&gt; QString(base64)"></a>QByteArray（base64） -&gt; QString(base64)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="function">QString <span class="title">byteArray2Base64String</span><span class="params">(QString fileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;image/picture.jpg&quot;</span>)</span></span>;<span class="comment">// 当然，你可以使用变量fileName</span></span><br><span class="line">    <span class="comment">//[重要] QIODevice使用前必须显示使用open</span></span><br><span class="line">    <span class="keyword">if</span>(!file.<span class="built_in">open</span>(QIODevice::ReadOnly))&#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;open file error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QByteArray byteArray = file.<span class="built_in">readAll</span>();</span><br><span class="line">    QString base64String = QString::<span class="built_in">fromUtf8</span>(byteArray.<span class="built_in">toBase64</span>());</span><br><span class="line">    <span class="comment">// base64字符都很长（超级长），直接打印控制无法显示</span></span><br><span class="line">    <span class="comment">// 使用QString::mid(int pos, int n); 打印1000个字符看看样子</span></span><br><span class="line">    <span class="comment">// qDebug() &lt;&lt; base64String.mid(0, 1000);</span></span><br><span class="line">    <span class="keyword">return</span> base64String;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*static QString QString::fromUtf8(const QByteArray &amp;)*支持从QByteArray载入字符，作为转换。</p><p><strong>结果预览</strong></p><p><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210514193333008.png" alt="image-20210514193333008"></p><h2 id="QString-base64-gt-QByteArray"><a href="#QString-base64-gt-QByteArray" class="headerlink" title="QString(base64) -&gt; QByteArray"></a>QString(base64) -&gt; QByteArray</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QByteArray&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string2Base64</span><span class="params">(QString&amp; baseStr, QByteArray &amp;byteArray)</span></span>&#123;</span><br><span class="line">byteArray = byteArray.<span class="built_in">fromBase64</span>(baseStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接利用*QByteArray::fromBase64(const QByteArray &amp;)*就能实现。那为什么要用函数呢？</p><p><strong>原因</strong></p><p>QByteArray是隐式共享的，就是说我们函数内构造出的QByteArray 对象在返回给外部的时候，它的内存空间因为离开了作用域被释放了！外部得到的是被释放的过的空间，而不是新的空间，此时一定会有空指针的异常。所以这里使用函数的方式来特别阐明这个问题（我们的QByteArray是外部传入的，这样函数返回时不会销毁它占用的内存空间）。</p><p>详细可以看看这篇文章，里面包含了Qt隐式共享实现的所有类。</p><p><a href="https://www.cnblogs.com/Vancamel/p/11346282.html">Qt框架浅析之一 ——- 隐式共享(Implicit Sharing)</a></p><p><strong>另外</strong></p><p>不可以直接使用构造函数来构造QByteArray，那样的出来的QByteArray并不是Utf8类型的，他的数据和原始数据是不对应的。谨记！</p><h2 id="打开二进制文件直接打印是什么样子？"><a href="#打开二进制文件直接打印是什么样子？" class="headerlink" title="打开二进制文件直接打印是什么样子？"></a>打开二进制文件直接打印是什么样子？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBinaryFile</span><span class="params">(QString fileName)</span></span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;image/picture.jpg&quot;</span>)</span></span>;<span class="comment">// 当然，你可以使用变量fileName</span></span><br><span class="line">    <span class="comment">//[重要] QIODevice使用前必须显示使用open</span></span><br><span class="line">    <span class="keyword">if</span>(!file.<span class="built_in">open</span>(QIODevice::ReadOnly))&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;open file error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QByteArray byteArray = file.<span class="built_in">readAll</span>();</span><br><span class="line">    <span class="comment">//[重要] 文件太大Qt无法打印的，只取1000个看看</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; byteArray.<span class="built_in">mid</span>(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果预览</strong></p><p><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210514195933865.png" alt="image-20210514195933865"></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中获取自增主键的最新自增值</title>
      <link href="/2021/07/20/mysql-zhong-huo-qu-zi-zeng-zhu-jian-de-zui-xin-zi-zeng-zhi/"/>
      <url>/2021/07/20/mysql-zhong-huo-qu-zi-zeng-zhu-jian-de-zui-xin-zi-zeng-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="MySql中插入数据时获取新增的主键"><a href="#MySql中插入数据时获取新增的主键" class="headerlink" title="MySql中插入数据时获取新增的主键"></a>MySql中插入数据时获取新增的主键</h2><p>有时候我们需要设计数据库时将主键设置为自增了，插入数据时使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_xxx</span><br><span class="line">(id, name)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="keyword">NULL</span>, <span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure><p>的方式。主键id的指定值是NULL时是默认自增的。</p><p>我们想在插入记录的同时获得刚刚插入的主键值，可以采用以下方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LAST_INSERT_ID();<span class="comment">-- 这是一个函数，保存了上一次数据插入时第一条自增ID的值</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@IDENTITY</span>;<span class="comment">-- 这是一个全局变量，保存了上一次生成的自增ID值</span></span><br></pre></td></tr></table></figure><p><em>LAST_INSERT_ID()在批量插入数据时，返回批量插入中第一个自增ID的值</em></p><p><em>@@IDENTITY永远返回最后一次生成的自增ID值</em></p><p>值得一提的是，采用以下方法是错误的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(id) <span class="keyword">FROM</span> tbl_xxx;</span><br></pre></td></tr></table></figure><p>性能低，并且在高并发的时候返回的值不正确。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>anaconda管理python环境</title>
      <link href="/2021/07/20/anaconda-guan-li-python-huan-jing/"/>
      <url>/2021/07/20/anaconda-guan-li-python-huan-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h2><h3 id="使用anoconda管理python版本"><a href="#使用anoconda管理python版本" class="headerlink" title="使用anoconda管理python版本"></a>使用anoconda管理python版本</h3><p><strong>为什么使用要进行版本管理？</strong></p><blockquote><p>python的版本管理问题一直是很令人头疼，因为使用python时可能需要针对工作的环境下载不同的依赖包，配置适合某个版本的整体的依赖包，例如说进行图像处理学习的整个依赖环境、进行深度学习的整个依赖环境。</p><p>使用anoconda管理python和依赖包可以达到便捷的目的。</p></blockquote><p><strong>创建一个使用anaconda的python工程</strong></p><p>我们需要在pycharm中创建一个基于anoconda环境的工程，在创建时就可以选择对应的python版本，同时项目创建完成时会在 <em>D:\Environment\anaconda\envs（我此时anaconda的根目录下的envs）</em> 目录下创建一个与工程同名的文件夹用于存储完整的环境依赖。</p><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210623230555160.png" /> </p><p align="center">创建一个包含完整依赖包的工程</p><p><strong>查看anaconda所有已创建的环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info -e # 控制台下</span><br></pre></td></tr></table></figure><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210623231759367.png" /> </p><p align="center">查看已创建的环境</p><p><strong>激活环境</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activate 工程名</span><br><span class="line"><span class="comment"># 例 activate Test</span></span><br></pre></td></tr></table></figure><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210711234256673.png" /> </p>             <p align="center">进入learn-demo虚拟环境</p><p><strong>安装只属于此环境的依赖包</strong></p><p>进入新创建的环境后我们可以使用pip工具安装只属于此环境的依赖包</p><p>①使用离线文件(如.whl)安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 文件全路径 # 可以将文件拖入控制台</span><br></pre></td></tr></table></figure><p>②在线安装(无翻墙情况下很慢)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy==1.18.5# 指定安装包的版本</span><br></pre></td></tr></table></figure><p><strong>python依赖包的获取网址</strong></p><p>python使用pip工具进行包管理，有时候需要下载离线包，可以从pypi网址上搜索各个版本的安装包。</p><p><a href="https://pypi.org/">https://pypi.org/</a></p><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210623225706899.png" /> </p><p align="center">pypi</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pymysql在Windows下的使用</title>
      <link href="/2021/07/20/pymysql-zai-windows-xia-de-shi-yong-1/"/>
      <url>/2021/07/20/pymysql-zai-windows-xia-de-shi-yong-1/</url>
      
        <content type="html"><![CDATA[<h2 id="windows上的MySQL服务安装"><a href="#windows上的MySQL服务安装" class="headerlink" title="windows上的MySQL服务安装"></a>windows上的MySQL服务安装</h2><p><strong>MySQL下载：</strong><br>官网提供的安装MySQL的方式有三种：<br>在线安装版：mysql-installer-web-community.msi<br>离线安装版：mysql-installer-community.msi<br>解压缩版：mysql-8.0.25-winx64.zip<br>但实质上只有两种，一种是用安装包安装，一种是用压缩包安装。<br>官网下载：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><p><em>解压安装解压后的文件夹放在能找到的地方，后续都会有用</em></p><p><strong>管理员模式下运行CMD！</strong></p><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210710211248662.png" /> </p>             <p align="center">根目录下的bin文件夹</p><p>进入解压后目录下的bin文件夹，此处能够启动mysql.exe程序。</p><p>输入以下命令并回车，初始化mysql…… 同时可以获取mysql的root账户生成的随机初始密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize --console</span><br></pre></td></tr></table></figure><p>结果如下， 但由于初始化过一次。这里使用D:\Environment\mysql-8.0.25-winx64\data 下的 ==LAPTOP-65M4UVJB.err==文件里的内容代替。（目测日志输出都会在这里，只要找到以.err为后缀的文件用记事本打开即可）</p><p>密码是红色标明的位置。</p><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210710212004821.png" /> </p><p align="center">一定要记住密码！实在实在不行去文件里看</p><p><strong>启动mysql服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br><span class="line">sc start mysql</span><br></pre></td></tr></table></figure><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210710212153589.png" /> </p><p align="center"></p><p><strong>进入mysql命令行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p# 登陆root账户</span><br></pre></td></tr></table></figure><p>需要输入密码</p><p>账号:root  密码:初始化生成的</p><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210710212335881.png" /> </p><p align="center">修改mysql账号密码</p><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;想要设置的密码&#x27;</span><br></pre></td></tr></table></figure><p><em>改个简单的密码！</em></p><h2 id="修改系统环境变量，任意处启动mysql命令行"><a href="#修改系统环境变量，任意处启动mysql命令行" class="headerlink" title="修改系统环境变量，任意处启动mysql命令行"></a>修改系统环境变量，任意处启动mysql命令行</h2><p>将==D:\Environment\mysql-8.0.25-winx64\bin==加入到系统环境变量中</p><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210710212902863.png" /> </p><p align="center">修改环境变量</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
