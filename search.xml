<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Qt中将二进制数据转换为Base64编码格式</title>
      <link href="/2021/07/20/qt-zhong-jiang-er-jin-zhi-shu-ju-zhuan-huan-wei-base64-bian-ma-ge-shi/"/>
      <url>/2021/07/20/qt-zhong-jiang-er-jin-zhi-shu-ju-zhuan-huan-wei-base64-bian-ma-ge-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>QJson格式是只支持字符传输的，不支持二进制文件（例如图片）。我们可以将二进制文件转换为base64字符串达到转换二进制图片文件为字符串的形式存入QJson</p><p><strong>base64是什么？</strong></p><blockquote><p>Base64是网络上最常见的用于传输字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范。</p><p>Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。</p></blockquote><h2 id="QByteArray-binary-gt-QByteArray-base64"><a href="#QByteArray-binary-gt-QByteArray-base64" class="headerlink" title="QByteArray(binary) -&gt; QByteArray(base64)"></a>QByteArray(binary) -&gt; QByteArray(base64)</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;QFile&gt;#include &lt;QString&gt;QByteArray openBinaryFileAndGetBase64(QString fileName)&#123;    &#x2F;&#x2F; ---------------打开文件，加载二进制文件----------------    QFile file(&quot;image&#x2F;picture.jpg&quot;);&#x2F;&#x2F; 当然，你可以使用变量fileName    &#x2F;&#x2F; [重要] QIODevice使用前必须显示使用open    if(!file.open(QIODevice::ReadOnly))&#123;qDebug() &lt;&lt; &quot;open file error&quot;;    &#125;    QByteArray byteArray &#x3D; file.readAll();    &#x2F;&#x2F; ----------------二进制字符数组转base64字符---------    byteArray &#x3D; byteArray.toBase64();    return byteArray;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很简单，但是很遗憾，虽然QByteArray本身使用字符类型数组作为底层数据结构，QJson却不支持直接使用QByteArray传图片（QJson没有这个基本类型啊！！！）。所以我们需要将QByteArray（base64）-&gt; QString 才能存QJson里边（QJson的基本类型有QString）。</p><h2 id="QByteArray（base64）-gt-QString-base64"><a href="#QByteArray（base64）-gt-QString-base64" class="headerlink" title="QByteArray（base64） -&gt; QString(base64)"></a>QByteArray（base64） -&gt; QString(base64)</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;QFile&gt;#include &lt;QString&gt;QString byteArray2Base64String(QString fileName)&#123;    QFile file(&quot;image&#x2F;picture.jpg&quot;);&#x2F;&#x2F; 当然，你可以使用变量fileName    &#x2F;&#x2F;[重要] QIODevice使用前必须显示使用open    if(!file.open(QIODevice::ReadOnly))&#123;qDebug() &lt;&lt; &quot;open file error&quot;;    &#125;    QByteArray byteArray &#x3D; file.readAll();    QString base64String &#x3D; QString::fromUtf8(byteArray.toBase64());    &#x2F;&#x2F; base64字符都很长（超级长），直接打印控制无法显示    &#x2F;&#x2F; 使用QString::mid(int pos, int n); 打印1000个字符看看样子    &#x2F;&#x2F; qDebug() &lt;&lt; base64String.mid(0, 1000);    return base64String;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>*static QString QString::fromUtf8(const QByteArray &amp;)*支持从QByteArray载入字符，作为转换。</p><p><strong>结果预览</strong></p><p><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210514193333008.png" alt="image-20210514193333008"></p><h2 id="QString-base64-gt-QByteArray"><a href="#QString-base64-gt-QByteArray" class="headerlink" title="QString(base64) -&gt; QByteArray"></a>QString(base64) -&gt; QByteArray</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;QByteArray&gt;void string2Base64(QString&amp; baseStr, QByteArray &amp;byteArray)&#123;byteArray &#x3D; byteArray.fromBase64(baseStr);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>直接利用*QByteArray::fromBase64(const QByteArray &amp;)*就能实现。那为什么要用函数呢？</p><p><strong>原因</strong></p><p>QByteArray是隐式共享的，就是说我们函数内构造出的QByteArray 对象在返回给外部的时候，它的内存空间因为离开了作用域被释放了！外部得到的是被释放的过的空间，而不是新的空间，此时一定会有空指针的异常。所以这里使用函数的方式来特别阐明这个问题（我们的QByteArray是外部传入的，这样函数返回时不会销毁它占用的内存空间）。</p><p>详细可以看看这篇文章，里面包含了Qt隐式共享实现的所有类。</p><p><a href="https://www.cnblogs.com/Vancamel/p/11346282.html">Qt框架浅析之一 ——- 隐式共享(Implicit Sharing)</a></p><p><strong>另外</strong></p><p>不可以直接使用构造函数来构造QByteArray，那样的出来的QByteArray并不是Utf8类型的，他的数据和原始数据是不对应的。谨记！</p><h2 id="打开二进制文件直接打印是什么样子？"><a href="#打开二进制文件直接打印是什么样子？" class="headerlink" title="打开二进制文件直接打印是什么样子？"></a>打开二进制文件直接打印是什么样子？</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void printBinaryFile(QString fileName)&#123;    QFile file(&quot;image&#x2F;picture.jpg&quot;);&#x2F;&#x2F; 当然，你可以使用变量fileName    &#x2F;&#x2F;[重要] QIODevice使用前必须显示使用open    if(!file.open(QIODevice::ReadOnly))&#123;        qDebug() &lt;&lt; &quot;open file error&quot;;    &#125;    QByteArray byteArray &#x3D; file.readAll();    &#x2F;&#x2F;[重要] 文件太大Qt无法打印的，只取1000个看看    qDebug() &lt;&lt; byteArray.mid(0, 1000);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果预览</strong></p><p><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210514195933865.png" alt="image-20210514195933865"></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中获取自增主键的最新自增值</title>
      <link href="/2021/07/20/mysql-zhong-huo-qu-zi-zeng-zhu-jian-de-zui-xin-zi-zeng-zhi/"/>
      <url>/2021/07/20/mysql-zhong-huo-qu-zi-zeng-zhu-jian-de-zui-xin-zi-zeng-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="MySql中插入数据时获取新增的主键"><a href="#MySql中插入数据时获取新增的主键" class="headerlink" title="MySql中插入数据时获取新增的主键"></a>MySql中插入数据时获取新增的主键</h2><p>有时候我们需要设计数据库时将主键设置为自增了，插入数据时使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> tbl_xxx<span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token string">'test'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>的方式。主键id的指定值是NULL时是默认自增的。</p><p>我们想在插入记录的同时获得刚刚插入的主键值，可以采用以下方法。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> LAST_INSERT_ID<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 这是一个函数，保存了上一次数据插入时第一条自增ID的值</span><span class="token keyword">SELECT</span> @<span class="token variable">@IDENTITY</span><span class="token punctuation">;</span><span class="token comment">-- 这是一个全局变量，保存了上一次生成的自增ID值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><em>LAST_INSERT_ID()在批量插入数据时，返回批量插入中第一个自增ID的值</em></p><p><em>@@IDENTITY永远返回最后一次生成的自增ID值</em></p><p>值得一提的是，采用以下方法是错误的。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">FROM</span> tbl_xxx<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>性能低，并且在高并发的时候返回的值不正确。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>anaconda管理python环境</title>
      <link href="/2021/07/20/anaconda-guan-li-python-huan-jing/"/>
      <url>/2021/07/20/anaconda-guan-li-python-huan-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h2><h3 id="使用anoconda管理python版本"><a href="#使用anoconda管理python版本" class="headerlink" title="使用anoconda管理python版本"></a>使用anoconda管理python版本</h3><p><strong>为什么使用要进行版本管理？</strong></p><blockquote><p>python的版本管理问题一直是很令人头疼，因为使用python时可能需要针对工作的环境下载不同的依赖包，配置适合某个版本的整体的依赖包，例如说进行图像处理学习的整个依赖环境、进行深度学习的整个依赖环境。</p><p>使用anoconda管理python和依赖包可以达到便捷的目的。</p></blockquote><p><strong>创建一个使用anaconda的python工程</strong></p><p>我们需要在pycharm中创建一个基于anoconda环境的工程，在创建时就可以选择对应的python版本，同时项目创建完成时会在 <em>D:\Environment\anaconda\envs（我此时anaconda的根目录下的envs）</em> 目录下创建一个与工程同名的文件夹用于存储完整的环境依赖。</p><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210623230555160.png" /> </p><p align="center">创建一个包含完整依赖包的工程</p><p><strong>查看anaconda所有已创建的环境</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda info -e # 控制台下<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210623231759367.png" /> </p><p align="center">查看已创建的环境</p><p><strong>激活环境</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">activate 工程名<span class="token comment"># 例 activate Test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210711234256673.png" /> </p>             <p align="center">进入learn-demo虚拟环境</p><p><strong>安装只属于此环境的依赖包</strong></p><p>进入新创建的环境后我们可以使用pip工具安装只属于此环境的依赖包</p><p>①使用离线文件(如.whl)安装</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pip install 文件全路径 # 可以将文件拖入控制台<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>②在线安装(无翻墙情况下很慢)</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pip install numpy&#x3D;&#x3D;1.18.5# 指定安装包的版本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>python依赖包的获取网址</strong></p><p>python使用pip工具进行包管理，有时候需要下载离线包，可以从pypi网址上搜索各个版本的安装包。</p><p><a href="https://pypi.org/">https://pypi.org/</a></p><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210623225706899.png" /> </p><p align="center">pypi</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pymysql在Windows下的使用</title>
      <link href="/2021/07/20/pymysql-zai-windows-xia-de-shi-yong/"/>
      <url>/2021/07/20/pymysql-zai-windows-xia-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="windows上的MySQL服务安装"><a href="#windows上的MySQL服务安装" class="headerlink" title="windows上的MySQL服务安装"></a>windows上的MySQL服务安装</h2><p><strong>MySQL下载：</strong><br>官网提供的安装MySQL的方式有三种：<br>在线安装版：mysql-installer-web-community.msi<br>离线安装版：mysql-installer-community.msi<br>解压缩版：mysql-8.0.25-winx64.zip<br>但实质上只有两种，一种是用安装包安装，一种是用压缩包安装。<br>官网下载：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><p><em>解压安装解压后的文件夹放在能找到的地方，后续都会有用</em></p><p><strong>管理员模式下运行CMD！</strong></p><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210710211248662.png" /> </p>             <p align="center">根目录下的bin文件夹</p><p>进入解压后目录下的bin文件夹，此处能够启动mysql.exe程序。</p><p>输入以下命令并回车，初始化mysql…… 同时可以获取mysql的root账户生成的随机初始密码</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mysqld --initialize --console<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下， 但由于初始化过一次。这里使用D:\Environment\mysql-8.0.25-winx64\data 下的 ==LAPTOP-65M4UVJB.err==文件里的内容代替。（目测日志输出都会在这里，只要找到以.err为后缀的文件用记事本打开即可）</p><p>密码是红色标明的位置。</p><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210710212004821.png" /> </p><p align="center">一定要记住密码！实在实在不行去文件里看</p><p><strong>启动mysql服务</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">net start mysqlsc start mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210710212153589.png" /> </p><p align="center"></p><p><strong>进入mysql命令行</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mysql -u root -p# 登陆root账户<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要输入密码</p><p>账号:root  密码:初始化生成的</p><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210710212335881.png" /> </p><p align="center">修改mysql账号密码</p><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;想要设置的密码&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>改个简单的密码！</em></p><h2 id="修改系统环境变量，任意处启动mysql命令行"><a href="#修改系统环境变量，任意处启动mysql命令行" class="headerlink" title="修改系统环境变量，任意处启动mysql命令行"></a>修改系统环境变量，任意处启动mysql命令行</h2><p>将==D:\Environment\mysql-8.0.25-winx64\bin==加入到系统环境变量中</p><p align="center"><img src="https://gitee.com/aiyudehua/drawing-bed/raw/master/https://gitee.com/aiyudehua/drawing-bed/tree/master/img/image-20210710212902863.png" /> </p><p align="center">修改环境变量</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
